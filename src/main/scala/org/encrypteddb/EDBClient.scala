package org.encrypteddb

import java.io.File
import java.util

import com.google.common.collect.ArrayListMultimap
import com.typesafe.scalalogging.StrictLogging
import org.crypto.sse._
import org.encrypteddb.utils.FileUtils

import scala.collection.JavaConverters._
import scala.util.{Random, Try}

class EDBClient(sk: Array[Byte]) extends FileUtils with StrictLogging {


  /**
    * Parse all documents from provided directory and generate update token to them
    *
    * @param dir - directory with documents to insert
    * @return Success on successful update, Failure otherwise
    */
  def insert(dir: File): Try[UpdateToken] = Try {
    val fileList = new util.ArrayList[File]
    TextProc.listf(dir.getAbsolutePath, fileList)
    TextProc.TextProc(false, dir.getAbsolutePath)
    val updateToken = DynRH.tokenUpdate(sk, TextExtractPar.lp1)
    logger.info(s"Update token for ${fileList.size()} documents with ${TextExtractPar.lp1.keySet.size} keywords and " +
      s"${TextExtractPar.lp1.keys.size} pairs is generated by the client")
    UpdateToken(updateToken)
  }

  /**
    * Generate update token for provided documents
    *
    * @param documents - array of id->content tuples
    * @return Success on successful update, Failure otherwise
    */
  def insert(documents: Seq[(String, String)]): Try[UpdateToken] = Try {
    // Empty the previous multimap to avoid adding the same set of documents for every update
    TextExtractPar.lp1 = ArrayListMultimap.create()
    // put documents to temp files to satisfy Clusion interfaces
    val insertDir: File = createTempDirForPrefix(Random.alphanumeric.take(10).mkString)
    documents foreach { doc =>
      createFileWithContent(insertDir, doc._1, doc._2)
    }
    insert(insertDir).get
  }

  /**
    * Generate a search query for provided keyword
    *
    * @param keyword - keyword to search
    * @return list of document ids
    */
  def search(keyword: String): SearchToken = {
    val token = DynRH.genTokenFS(sk, keyword)
    val key2 = CryptoPrimitives.generateCmac(sk, 1 + new String)
    SearchToken(token, key2)
  }

}

object EDBClient {
  def create(): EDBClient = {
    val sk: Array[Byte] = RR2Lev.keyGen(256, Random.nextString(256), "salt/salt", 100000)
    new EDBClient(sk)
  }
}

