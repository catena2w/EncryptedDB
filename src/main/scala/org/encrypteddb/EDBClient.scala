package org.encrypteddb

import java.io.File
import java.util

import com.google.common.collect.ArrayListMultimap
import com.typesafe.scalalogging.StrictLogging
import org.crypto.sse._
import org.encrypteddb.utils.FileUtils

import scala.util.Random

/**
  * A EDB client, that holds secret key `sk` and generates update and search tokens
  *
  * @param sk secret key
  */
class EDBClient(sk: Array[Byte]) extends FileUtils with StrictLogging {

  /**
    * Generates a delete token, that will exclude `index` document from `keyword` search result
    *
    * @param keyword - keyword for which delete operation will be performed
    * @param index   - index of the document within keyword search results
    * @return token that will allow server to filter out deleted document
    */
  def delete(keyword: String, index: Int): DeleteToken = {
    val deletions = new util.ArrayList[Integer]
    deletions.add(index.toInt)
    val key1 = DynRH.delToken(sk, keyword)
    DeleteToken(key1, List(index))
  }

  /**
    * Parse all documents from provided directory and generate update token to them
    *
    * @param dir - directory with documents to insert
    * @return token that will allow server to insert these documents
    */
  def insert(dir: File): InsertToken = {
    // Empty the previous multimap to avoid adding the same set of documents for every update
    TextExtractPar.lp1 = ArrayListMultimap.create()
    val fileList = new util.ArrayList[File]
    TextProc.listf(dir.getAbsolutePath, fileList)
    TextProc.TextProc(false, dir.getAbsolutePath)
    val updateToken = DynRH.tokenUpdate(sk, TextExtractPar.lp1)
    logger.info(s"Update token for ${fileList.size()} documents with ${TextExtractPar.lp1.keySet.size} keywords and " +
      s"${TextExtractPar.lp1.keys.size} pairs is generated by the client")
    InsertToken(updateToken)
  }

  /**
    * Generate update token for provided documents
    *
    * @param documents - array of id->content tuples
    * @return token that will allow server to insert these documents
    */
  def insert(documents: Seq[(String, String)]): InsertToken = {
    // put documents to temp files to satisfy Clusion interfaces
    val insertDir: File = createTempDirForPrefix(Random.alphanumeric.take(10).mkString)
    documents foreach { doc =>
      createFileWithContent(insertDir, doc._1, doc._2)
    }
    insert(insertDir)
  }

  /**
    * Generate a search query for provided keyword
    *
    * @param keyword - keyword to search
    * @return token that will allow server to find all documents with this keyword
    */
  def search(keyword: String): SearchToken = {
    val token = DynRH.genTokenFS(sk, keyword)
    val key2 = CryptoPrimitives.generateCmac(sk, 1 + new String)
    SearchToken(token, key2)
  }

}

object EDBClient {
  def create(): EDBClient = {
    val sk: Array[Byte] = RR2Lev.keyGen(256, Random.nextString(256), "salt/salt", 100000)
    new EDBClient(sk)
  }
}

